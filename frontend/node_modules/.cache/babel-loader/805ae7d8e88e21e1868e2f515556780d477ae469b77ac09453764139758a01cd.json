{"ast":null,"code":"var _process$env$REACT_AP,\n  _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst WS_BASE_URL = ((_process$env$REACT_AP = process.env.REACT_APP_API_URL) === null || _process$env$REACT_AP === void 0 ? void 0 : _process$env$REACT_AP.replace('http', 'ws')) || 'ws://127.0.0.1:8000/api';\n\n/**\n * Custom hook for WebSocket connection\n * Handles real-time chat communication with the backend\n */\nexport const useWebSocket = sessionId => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n  const ws = useRef(null);\n  const reconnectTimeout = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const isConnecting = useRef(false); // Prevent duplicate connections\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (!sessionId) {\n      console.warn('No session ID provided for WebSocket');\n      return;\n    }\n\n    // Prevent multiple simultaneous connection attempts\n    if (isConnecting.current || ws.current && ws.current.readyState === WebSocket.OPEN) {\n      console.log('Already connecting or connected, skipping...');\n      return;\n    }\n    isConnecting.current = true;\n    try {\n      const wsUrl = `${WS_BASE_URL}/ws/chat/${sessionId}`;\n      console.log('Connecting to WebSocket:', wsUrl);\n      ws.current = new WebSocket(wsUrl);\n      ws.current.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n        isConnecting.current = false;\n      };\n      ws.current.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('WebSocket message received:', data);\n          setMessages(prev => [...prev, data]);\n        } catch (err) {\n          console.error('Error parsing WebSocket message:', err);\n        }\n      };\n      ws.current.onerror = event => {\n        console.error('WebSocket error:', event);\n        setError('WebSocket connection error');\n        isConnecting.current = false;\n      };\n      ws.current.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        isConnecting.current = false;\n\n        // Attempt to reconnect\n        if (reconnectAttempts.current < maxReconnectAttempts) {\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 10000);\n          console.log(`Reconnecting in ${delay}ms... (attempt ${reconnectAttempts.current + 1})`);\n          reconnectTimeout.current = setTimeout(() => {\n            reconnectAttempts.current += 1;\n            connect();\n          }, delay);\n        } else {\n          setError('Failed to connect to server. Please refresh the page.');\n        }\n      };\n    } catch (err) {\n      console.error('Error creating WebSocket:', err);\n      setError('Failed to establish WebSocket connection');\n      isConnecting.current = false;\n    }\n  }, [sessionId]);\n\n  // Send message through WebSocket\n  const sendMessage = useCallback((type, data) => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      const message = {\n        type,\n        ...data,\n        timestamp: new Date().toISOString()\n      };\n      console.log('Sending WebSocket message:', message);\n      ws.current.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n\n  // Send candidate answer\n  const sendAnswer = useCallback(message => {\n    sendMessage('answer', {\n      message\n    });\n  }, [sendMessage]);\n\n  // Send ping (heartbeat)\n  const sendPing = useCallback(() => {\n    sendMessage('ping', {});\n  }, [sendMessage]);\n\n  // Disconnect WebSocket\n  const disconnect = useCallback(() => {\n    if (reconnectTimeout.current) {\n      clearTimeout(reconnectTimeout.current);\n    }\n    if (ws.current) {\n      ws.current.close();\n      ws.current = null;\n    }\n    setIsConnected(false);\n  }, []);\n\n  // Connect on mount, disconnect on unmount\n  useEffect(() => {\n    if (sessionId) {\n      connect();\n    }\n    return () => {\n      disconnect();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sessionId]); // Only reconnect when sessionId changes\n\n  // Heartbeat to keep connection alive\n  useEffect(() => {\n    if (!isConnected) return;\n    const heartbeatInterval = setInterval(() => {\n      sendPing();\n    }, 30000); // Send ping every 30 seconds\n\n    return () => {\n      clearInterval(heartbeatInterval);\n    };\n  }, [isConnected, sendPing]);\n  return {\n    isConnected,\n    messages,\n    error,\n    sendAnswer,\n    sendMessage,\n    disconnect,\n    reconnect: connect\n  };\n};\n_s(useWebSocket, \"ezJ7+VxT6F2VfvnfFY9IG1GbXno=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","WS_BASE_URL","_process$env$REACT_AP","process","env","REACT_APP_API_URL","replace","useWebSocket","sessionId","_s","isConnected","setIsConnected","messages","setMessages","error","setError","ws","reconnectTimeout","reconnectAttempts","maxReconnectAttempts","isConnecting","connect","console","warn","current","readyState","WebSocket","OPEN","log","wsUrl","onopen","onmessage","event","data","JSON","parse","prev","err","onerror","onclose","delay","Math","min","pow","setTimeout","sendMessage","type","message","timestamp","Date","toISOString","send","stringify","sendAnswer","sendPing","disconnect","clearTimeout","close","heartbeatInterval","setInterval","clearInterval","reconnect"],"sources":["C:/Users/rithv/OneDrive/Desktop/mp_interviewer/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\nconst WS_BASE_URL = process.env.REACT_APP_API_URL?.replace('http', 'ws') || 'ws://127.0.0.1:8000/api';\n\n/**\n * Custom hook for WebSocket connection\n * Handles real-time chat communication with the backend\n */\nexport const useWebSocket = (sessionId) => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n  const ws = useRef(null);\n  const reconnectTimeout = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const isConnecting = useRef(false); // Prevent duplicate connections\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (!sessionId) {\n      console.warn('No session ID provided for WebSocket');\n      return;\n    }\n\n    // Prevent multiple simultaneous connection attempts\n    if (isConnecting.current || (ws.current && ws.current.readyState === WebSocket.OPEN)) {\n      console.log('Already connecting or connected, skipping...');\n      return;\n    }\n\n    isConnecting.current = true;\n\n    try {\n      const wsUrl = `${WS_BASE_URL}/ws/chat/${sessionId}`;\n      console.log('Connecting to WebSocket:', wsUrl);\n      \n      ws.current = new WebSocket(wsUrl);\n\n      ws.current.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        setError(null);\n        reconnectAttempts.current = 0;\n        isConnecting.current = false;\n      };\n\n      ws.current.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('WebSocket message received:', data);\n          \n          setMessages((prev) => [...prev, data]);\n        } catch (err) {\n          console.error('Error parsing WebSocket message:', err);\n        }\n      };\n\n      ws.current.onerror = (event) => {\n        console.error('WebSocket error:', event);\n        setError('WebSocket connection error');\n        isConnecting.current = false;\n      };\n\n      ws.current.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        isConnecting.current = false;\n        \n        // Attempt to reconnect\n        if (reconnectAttempts.current < maxReconnectAttempts) {\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 10000);\n          console.log(`Reconnecting in ${delay}ms... (attempt ${reconnectAttempts.current + 1})`);\n          \n          reconnectTimeout.current = setTimeout(() => {\n            reconnectAttempts.current += 1;\n            connect();\n          }, delay);\n        } else {\n          setError('Failed to connect to server. Please refresh the page.');\n        }\n      };\n    } catch (err) {\n      console.error('Error creating WebSocket:', err);\n      setError('Failed to establish WebSocket connection');\n      isConnecting.current = false;\n    }\n  }, [sessionId]);\n\n  // Send message through WebSocket\n  const sendMessage = useCallback((type, data) => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      const message = {\n        type,\n        ...data,\n        timestamp: new Date().toISOString(),\n      };\n      \n      console.log('Sending WebSocket message:', message);\n      ws.current.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket is not connected');\n      setError('Not connected to server');\n    }\n  }, []);\n\n  // Send candidate answer\n  const sendAnswer = useCallback((message) => {\n    sendMessage('answer', { message });\n  }, [sendMessage]);\n\n  // Send ping (heartbeat)\n  const sendPing = useCallback(() => {\n    sendMessage('ping', {});\n  }, [sendMessage]);\n\n  // Disconnect WebSocket\n  const disconnect = useCallback(() => {\n    if (reconnectTimeout.current) {\n      clearTimeout(reconnectTimeout.current);\n    }\n    \n    if (ws.current) {\n      ws.current.close();\n      ws.current = null;\n    }\n    \n    setIsConnected(false);\n  }, []);\n\n  // Connect on mount, disconnect on unmount\n  useEffect(() => {\n    if (sessionId) {\n      connect();\n    }\n\n    return () => {\n      disconnect();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sessionId]); // Only reconnect when sessionId changes\n\n  // Heartbeat to keep connection alive\n  useEffect(() => {\n    if (!isConnected) return;\n\n    const heartbeatInterval = setInterval(() => {\n      sendPing();\n    }, 30000); // Send ping every 30 seconds\n\n    return () => {\n      clearInterval(heartbeatInterval);\n    };\n  }, [isConnected, sendPing]);\n\n  return {\n    isConnected,\n    messages,\n    error,\n    sendAnswer,\n    sendMessage,\n    disconnect,\n    reconnect: connect,\n  };\n};\n\nexport default useWebSocket;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}